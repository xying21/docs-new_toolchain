"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9190],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=s,m=p["".concat(i,".").concat(u)]||p[u]||h[u]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function u(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=p;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:s,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5568:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>l,contentTitle:()=>i,metadata:()=>c,toc:()=>d,default:()=>p});var a=n(7462),s=n(3366),o=(n(7294),n(3905)),r=["components"],l={id:"cell-model",title:"Cell Model"},i=void 0,c={unversionedId:"basics/concepts/cell-model",id:"basics/concepts/cell-model",title:"Cell Model",description:"What is a Cell?",source:"@site/docs/basics/concepts/cell-model.md",sourceDirName:"basics/concepts",slug:"/basics/concepts/cell-model",permalink:"/develop/docs/basics/concepts/cell-model",tags:[],version:"current",frontMatter:{id:"cell-model",title:"Cell Model"},sidebar:"Basics",previous:{title:"Nervos Blockchain",permalink:"/develop/docs/basics/concepts/nervos-blockchain"},next:{title:"Consensus",permalink:"/develop/docs/basics/concepts/consensus"}},d=[{value:"What is a Cell?",id:"what-is-a-cell",children:[],level:2},{value:"What is the Cell Model?",id:"what-is-the-cell-model",children:[],level:2},{value:"First-Class Assets",id:"first-class-assets",children:[],level:2},{value:"Transaction Fees Paid by Anyone",id:"transaction-fees-paid-by-anyone",children:[],level:2},{value:"Scalability",id:"scalability",children:[],level:2},{value:"Further Reading",id:"further-reading",children:[],level:2}],h={toc:d};function p(e){var t=e.components,n=(0,s.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"what-is-a-cell"},"What is a Cell?"),(0,o.kt)("p",null,"Cell is the most basic structure for representing a single piece of data in Nervos. The data contained in a Cell can take many forms, including CKBytes, tokens, code in Javascript, or even serialized data like JSON strings. As there is no restriction on the type of data included, developers have full flexibility in their choices."),(0,o.kt)("p",null,"Each Cell contains a small program called a ",(0,o.kt)("strong",{parentName:"p"},"Lock Script")," that defines who has permission to use it. In general, the Lock Script defines one user as the owner of a Cell, it can also do more complex operations such as having multiple owners (multi-sig) or conditional uses of time-locking within particular time-frames."),(0,o.kt)("p",null,"A Cell can opt to include a second program, called a ",(0,o.kt)("strong",{parentName:"p"},"Type Script"),", to execute a set of rules on the usage of cell. As a result, developers are empowered to create complex smart across a wide range of use cases, from CryptoKitties to tokens, DeFi, and everything in between."),(0,o.kt)("h2",{id:"what-is-the-cell-model"},"What is the Cell Model?"),(0,o.kt)("p",null,"The cell model defines how each cell in Nervos acts and interacts with each other, and the process must be followed for updating the data contained within the cells. People familiar with Bitcoin\u2019s UTXO model may notice the similarities, because the cell model was inspired by it."),(0,o.kt)("p",null,"Cells are immutable. This means no changes can be mande once cells have been added to the blockchain. For any data update, the containing cell must undergo a process called ",(0,o.kt)("strong",{parentName:"p"},"consumption"),". When a Cell is ",(0,o.kt)("strong",{parentName:"p"},"consumed"),", data gets extracted and the cell gets destroyed. The data can be updated as needed while being extracted. A new cell with updated data will then be created and added to the blockchain."),(0,o.kt)("p",null,"Each Cell can be consumed only once. A non-consumed cell is known as a ",(0,o.kt)("strong",{parentName:"p"},"live cell"),". A consumed cell is known as a ",(0,o.kt)("strong",{parentName:"p"},"dead cell"),". Once dead, the cell can no longer be used."),(0,o.kt)("p",null,"Transactions serve to explain the changes in cell data. The transaction specifies a group of live cells to consume and a group of new cells to create by using the updated data. The network validates the transaction by executing all lock scripts and type scripts of each cell contained in the transaction. This ensures that all rules defined by the developers are being followed without any fraud."),(0,o.kt)("h2",{id:"first-class-assets"},"First-Class Assets"),(0,o.kt)("p",null,"Nervos\u2019 cell model treats all digital assets, such as CKBytes, tokens, and digital collectibles, as the exclusive property and responsibility of their owner. Assets must adhere to smart contract rules when being included in transactions, but the asset inherently belongs to the user instead of the smart contract. The difference is subtle but critical. "),(0,o.kt)("p",null,"When a user owns an asset, then only that user has permission to use the asset. Even the smart contract that defines the token has no permission to the asset. This means that even if an attacker found an exploit in the contract code, he or she would remain locked out of the asset because the asset is under user control. The impact of the attack is fully mitigated."),(0,o.kt)("p",null,"Having a defined ownership of the asset also clarifies who is responsible for its upkeep. As assets take up space on Nervos, there will be a small recurring upkeep fee, commonly known as ",(0,o.kt)("strong",{parentName:"p"},"state rent"),". User is the owner and is responsible as such, not the smart contract. More about state rent will be covered in the ",(0,o.kt)("a",{parentName:"p",href:"economics"},"Economics")," section."),(0,o.kt)("h2",{id:"transaction-fees-paid-by-anyone"},"Transaction Fees Paid by Anyone"),(0,o.kt)("p",null,"In most cases, people who send funds or execute smart contracts pay the transaction fees. However, to have a different party cover the associated fees can be beneficial in some cases."),(0,o.kt)("p",null,"A common scenario is the transfer of tokens from one party to another. The sender must own the tokens wanted to be transferred and sufficient CKBytes to cover the transaction cost. This creates an usability problem to users."),(0,o.kt)("p",null,"The flexibility of the cell model allows any party to pay the transaction fees. This can significantly improve the user experience since owning CKBytes is no longer an absolute requirement. The receiver or a third-party can pay the fee, easing the process for users."),(0,o.kt)("h2",{id:"scalability"},"Scalability"),(0,o.kt)("p",null,"The cell model separates the concepts of computation and validation for smart contract execution. Computation is the process of generating new data, which is done off-chain before the transaction gets sent to the network. Validation ensures that the data conforms to the rules set by the developers, which is done on-chain by full nodes after being received by the network. Offloading computation reduces the burden on full nodes and improves the total processing capacity of the network."),(0,o.kt)("p",null,"Smart contract execution is parallel in the cell model. Each transaction runs independently in its own virtual machine. And, multiple virtual machines run simultaneously rather than sequentially. This gives the cell model dramatic scaling improvements on modern computers - computers that increase the number of CPU cores with each generation."),(0,o.kt)("p",null,"Transactions are very flexible in the cell model. Multiple smart contract operations can often be batched into a single transaction, eliminating the need to construct multiple distinct transactions. This decreases the overhead involved in transactions and simplifies the process by reducing the required processing and transaction fees."),(0,o.kt)("p",null,"The unique structure of the cell model grants an inherent scalability. The conbination of these methods enables Nervos to achieve a greater level of smart contract scalability. A level that would not be possible in other ways."),(0,o.kt)("h2",{id:"further-reading"},"Further Reading"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For more information, please see Nervos Network\u2019s blog post on the ",(0,o.kt)("a",{parentName:"li",href:"https://medium.com/nervosnetwork/https-medium-com-nervosnetwork-cell-model-7323fca57571"},"Cell Model"),".")))}p.isMDXComponent=!0}}]);