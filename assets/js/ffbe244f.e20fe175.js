"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8158],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=c(t),h=o,f=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return t?a.createElement(f,s(s({ref:n},d),{},{components:t})):a.createElement(f,s({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,s=new Array(i);s[0]=u;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<i;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1988:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>r,contentTitle:()=>l,metadata:()=>c,toc:()=>d,default:()=>u});var a=t(7462),o=t(3366),i=(t(7294),t(3905)),s=["components"],r={id:"lumos-nervosdao",title:"Introduction to Lumos via NervosDAO"},l=void 0,c={unversionedId:"labs/lumos-nervosdao",id:"labs/lumos-nervosdao",title:"Introduction to Lumos via NervosDAO",description:"In the real world, one hardly sees a blockchain exposed and used directly by the ordinary users. Apps, websites or other services are built on top of blockchains to provide a seamless service. Based on this belief, we built lumos, a JavaScript/TypeScript framework, that aids dapp development on CKB. Lumos should be able to free you from most, if not all of the hassles for dealing with CKB, and let you focus on the specific logic in your dapp.",source:"@site/docs/labs/lumos-nervosdao.md",sourceDirName:"labs",slug:"/labs/lumos-nervosdao",permalink:"/develop/docs/labs/lumos-nervosdao",tags:[],version:"current",frontMatter:{id:"lumos-nervosdao",title:"Introduction to Lumos via NervosDAO"},sidebar:"Labs",previous:{title:"Write an SUDT Script by Capsule",permalink:"/develop/docs/labs/sudtbycapsule"},next:{title:"Dynamic loading in Capsule",permalink:"/develop/docs/labs/capsule-dynamic-loading-tutorial"}},d=[{value:"Components",id:"components",children:[],level:2},{value:"Initial CKB Setup",id:"initial-ckb-setup",children:[],level:2},{value:"Node Skeleton",id:"node-skeleton",children:[],level:2},{value:"Config Manager Setup",id:"config-manager-setup",children:[],level:2},{value:"Booting Indexer",id:"booting-indexer",children:[],level:2},{value:"Deposit",id:"deposit",children:[{value:"Transaction Skeleton",id:"transaction-skeleton",children:[],level:3}],level:2},{value:"Withdraw",id:"withdraw",children:[{value:"Locktime Pool",id:"locktime-pool",children:[],level:3}],level:2},{value:"Common Script",id:"common-script",children:[],level:2},{value:"Recap",id:"recap",children:[],level:2}],p={toc:d};function u(e){var n=e.components,t=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In the real world, one hardly sees a blockchain exposed and used directly by the ordinary users. Apps, websites or other services are built on top of blockchains to provide a seamless service. Based on this belief, we built ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nervosnetwork/lumos"},"lumos"),", a JavaScript/TypeScript framework, that aids dapp development on CKB. Lumos should be able to free you from most, if not all of the hassles for dealing with CKB, and let you focus on the specific logic in your dapp."),(0,i.kt)("p",null,"In this tutorial, we will provide an introduction on lumos via a real example: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.md"},"Nervos DAO"),", while quite valuable on CKB, can be a real pain to integrate for many dapps. Here we will demonstrate that how lumos can be used to streamline Nervos DAO integration."),(0,i.kt)("h2",{id:"components"},"Components"),(0,i.kt)("p",null,"Lumos is designed as a framework, meaning it is expected to be used in a intrinsic way: certain setup code will be needed when you first boot your application. Global states might also be kept in your application memory space for bookkeeping purposes. That being said, lumos is also organized into several components, some of which might be used in a non-intrinsic stateless fashion. In general, lumos consists of the following components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/indexer"},"indexer"),": a CKB cell indexer that fulfills ",(0,i.kt)("a",{parentName:"li",href:"../reference/cell#index-query-assemble-pattern"},"Index-Query-Assemble")," pattern. For now, this package only contains RocksDB backed indexer. A ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/sql-indexer"},"separate pacakge")," contains SQL backed indexer using the same interface. Later, we might merge the 2 packages into one for consistency."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/base"},"base"),": a base package containing common types and utilities that are used by most packages. If there is a CKB specific task you need to perform, you might want to look here first. Chances are they are already provided."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/helpers"},"helpers"),": a helper package containing more utilities. The difference between ",(0,i.kt)("inlineCode",{parentName:"li"},"helpers")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"base"),", is that ",(0,i.kt)("inlineCode",{parentName:"li"},"base")," contains pure stateless functions, while ",(0,i.kt)("inlineCode",{parentName:"li"},"helpers")," works in a more intrinsic way: it requires ",(0,i.kt)("inlineCode",{parentName:"li"},"config-manager")," mentioned below to be setup."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/common-scripts"},"common-scripts"),": integrations for known scripts on CKB. While we try our best to provide integrations for popular CKB scripts, people might be working on innovations everyday. As a result, we are also designing a set of APIs, so developers can freely integrate their own scripts into lumos for everyone to use. One integrated, ",(0,i.kt)("inlineCode",{parentName:"li"},"common-scripts")," should be able to leverage those new scripts as well."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/config-manager"},"config-manager"),": a manager for dealing with differences between different chains, such as mainnet, testnet, or numerous dev chains. We abstract each chain into individual config file. Once loaded, config manager will be able to handle the chain specific logic, so you don't have to deal with this in your own code."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/lumos/tree/v0.4.0/packages/transaction-manager"},"transaction-manager"),": a transaction manager for CKB. One problem with UTXO based blockchains, is that a certain amount of gap period exists between a transaction is accepted by a blockchain, and when it is actually committed on chain. During this gap, new cells created by the pending transaction will not be available. Transaction manager package takes care of this. It wraps an indexer instance, and makes sure cells created in pending transactions, are also exposed and available for assembling new transactions. This means you are no longer bounded to one transaction at a time, you can freely send series of transactions as you wish.")),(0,i.kt)("h2",{id:"initial-ckb-setup"},"Initial CKB Setup"),(0,i.kt)("p",null,"To ease the whole process so we don't have to wait too long to see the results, let's setup our own dev chain with ",(0,i.kt)("a",{parentName:"p",href:"basics/guides/devchain#modify-parameters-to-run-quickly"},"tweaks"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ export TOP=$(pwd)\n# I\'m testing this on a Linux machine, if you use other platforms, please adjust\n# this accordingly.\n$ curl -LO https://github.com/nervosnetwork/ckb/releases/download/v0.33.0/ckb_v0.33.0_x86_64-unknown-linux-gnu.tar.gz\n$ tar xzf ckb_v0.33.0_x86_64-unknown-linux-gnu.tar.gz\n$ export PATH=$PATH:$TOP/ckb_v0.33.0_x86_64-unknown-linux-gnu\n$ ckb -V\nckb 0.33.0\n$ ckb init -C devnet -c dev\n$ ed devnet/specs/dev.toml <<EOF\n91d\n90a\ngenesis_epoch_length = 10\npermanent_difficulty_in_dummy = true\n.\nwq\nEOF\n$ ed devnet/ckb-miner.toml <<EOF\n39s/5000/1000/\nwq\nEOF\n$ ed devnet/ckb.toml <<EOF\n143a\n[block_assembler]\ncode_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"\n# private key: 0x29159d8bb4b27704b168fc7fae70ffebf82164ce432b3f6b4c904a116a969f19\nargs = "0xcbfbb9edb5838e2d61061c3fc69eaaa5fdbd3273"\nhash_type = "type"\nmessage = "0x"\n.\nwq\nEOF\n$ ckb run -C devnet\n')),(0,i.kt)("p",null,"Here we are making the following configuration:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create a dev chain"),(0,i.kt)("li",{parentName:"ul"},"Modify the chain config to skip difficulty adjustment, and set all epoch to contain 10 blocks"),(0,i.kt)("li",{parentName:"ul"},"Modify miner config to generate a new block every second"),(0,i.kt)("li",{parentName:"ul"},"Use a specific private key as the wallet used in miner. Please do not use this private key elsewhere!"),(0,i.kt)("li",{parentName:"ul"},"Start a CKB node with the dev chain")),(0,i.kt)("p",null,"In a different terminal, we can also start the CKB miner:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ export TOP=$(pwd)\n$ export PATH=$PATH:$TOP/ckb_v0.33.0_x86_64-unknown-linux-gnu\n$ ckb miner -C devnet\n")),(0,i.kt)("h2",{id:"node-skeleton"},"Node Skeleton"),(0,i.kt)("p",null,"Now with CKB ready, we can create the node skeleton used to run our JS code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ mkdir nervosdao-skeleton\n$ cd nervosdao-skeleton\n$ yarn init\n$ yarn add @ckb-lumos/indexer@0.4.3 @ckb-lumos/common-scripts@0.4.3\n")),(0,i.kt)("p",null,"In this lab, we will run the operation needed from a node shell with async/await enabled:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ node --experimental-repl-await\nWelcome to Node.js v12.16.2.\nType ".help" for more information.\n>\n')),(0,i.kt)("p",null,"But this is only for demonstration purposes. There's nothing stopping you from copying the same code into a file that is then executed by node."),(0,i.kt)("h2",{id:"config-manager-setup"},"Config Manager Setup"),(0,i.kt)("p",null,"The first step in using lumos, is setting up config manager. Even though CKB has a unified programming model, different configurations would still be required for different chain instances, such as mainnet, testnet or dev chains. Config manager allows the node app to boot with a specific chain configuration, so other parts in lumos can consult config manager directly for information."),(0,i.kt)("p",null,"If you are using a well known chain configuration, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"LUMOS_CONFIG_NAME")," environment variable to setup config manager:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ LUMOS_CONFIG_NAME=LINA node --experimental-repl-await\nWelcome to Node.js v12.16.2.\nType \".help\" for more information.\n> const { initializeConfig, getConfig } = require(\"@ckb-lumos/config-manager\");\n> initializeConfig();\n> getConfig();\n{\n  PREFIX: 'ckb',\n  SCRIPTS: {\n    SECP256K1_BLAKE160: {\n      CODE_HASH: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',\n      HASH_TYPE: 'type',\n      TX_HASH: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',\n      INDEX: '0x0',\n      DEP_TYPE: 'dep_group',\n      SHORT_ID: 0\n    },\n    SECP256K1_BLAKE160_MULTISIG: {\n      CODE_HASH: '0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8',\n      HASH_TYPE: 'type',\n      TX_HASH: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',\n      INDEX: '0x1',\n      DEP_TYPE: 'dep_group',\n      SHORT_ID: 1\n    },\n    DAO: {\n      CODE_HASH: '0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e',\n      HASH_TYPE: 'type',\n      TX_HASH: '0xe2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c',\n      INDEX: '0x2',\n      DEP_TYPE: 'code'\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Supported well known configurations include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LINA"),": mainnet config;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AGGRON4"),": current testnet config. Note at certain time, we might reset testnet, in that case, lumos might be upgraded with new testnet configurations.")),(0,i.kt)("p",null,"However there might be cases, where you don't use a pre-defined configuration. For example, the dev chain we use here, does not have a pre-defined configuration. Lumos also supports setting up config manager via a local config file. You can use ",(0,i.kt)("inlineCode",{parentName:"p"},"LUMOS_CONFIG_FILE")," environment variable to point to the config file. If neither config variable is set, lumos will try to read config file from ",(0,i.kt)("inlineCode",{parentName:"p"},"config.json")," file in current directory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ cat <<EOF > config.json\n{\n  "PREFIX": "ckt",\n  "SCRIPTS": {\n    "SECP256K1_BLAKE160": {\n      "CODE_HASH": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",\n      "HASH_TYPE": "type",\n      "TX_HASH": "0xace5ea83c478bb866edf122ff862085789158f5cbff155b7bb5f13058555b708",\n      "INDEX": "0x0",\n      "DEP_TYPE": "dep_group",\n      "SHORT_ID": 0\n    },\n    "SECP256K1_BLAKE160_MULTISIG": {\n      "CODE_HASH": "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",\n      "HASH_TYPE": "type",\n      "TX_HASH": "0xace5ea83c478bb866edf122ff862085789158f5cbff155b7bb5f13058555b708",\n      "INDEX": "0x1",\n      "DEP_TYPE": "dep_group",\n      "SHORT_ID": 1\n    },\n    "DAO": {\n      "CODE_HASH": "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",\n      "HASH_TYPE": "type",\n      "TX_HASH": "0xa563884b3686078ec7e7677a5f86449b15cf2693f3c1241766c6996f206cc541",\n      "INDEX": "0x2",\n      "DEP_TYPE": "code"\n    }\n  }\n}\nEOF\n$ LUMOS_CONFIG_FILE="config.json" node --experimental-repl-await\nWelcome to Node.js v12.16.2.\nType ".help" for more information.\n> const { initializeConfig, getConfig } = require("@ckb-lumos/config-manager");\n> initializeConfig();\n')),(0,i.kt)("p",null,"Now config manager is successfully setup, we can proceed to the next step."),(0,i.kt)("h2",{id:"booting-indexer"},"Booting Indexer"),(0,i.kt)("p",null,"Lumos is designed based on the ",(0,i.kt)("a",{parentName:"p",href:"../reference/cell#index-query-assemble-pattern"},"Index-Query-Assemble")," pattern, meaning a dapp shall hava an indexer that keeps indexing new blocks in a format that is easier to query. This means any dapp built with lumos, should also have an indexer configured and running at all time:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> const { Indexer } = require("@ckb-lumos/indexer");\n> const indexer = new Indexer("http://127.0.0.1:8114", "./indexed-data");\n> indexer.startForever();\n')),(0,i.kt)("p",null,"Here we are using the RocksDB backed indexer for simplicity. Lumos provides 2 indexer types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"RocksDB backed indexer"),(0,i.kt)("li",{parentName:"ul"},"SQL backed indexer, supported SQL databases now include MySQL and PostgreSQL.")),(0,i.kt)("p",null,"If you want to test against the SQL indexer, some modifications to the above setup code might be required."),(0,i.kt)("p",null,"You can check current indexed tip with the following code snippet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> await indexer.tip()\n{\n  block_number: "0x29c",\n  block_hash: "0x3e44b571c82a09117231baee1939d38440d71f56de8bc600ac32b1dead9be46d"\n}\n')),(0,i.kt)("p",null,"Please wait a while till lumos has caught up with the current chain tip. This should not take much time for a dev chain."),(0,i.kt)("h2",{id:"deposit"},"Deposit"),(0,i.kt)("p",null,"To deposit to Nervos DAO, we need to first create a deposit transaction. You could of course go the hard way and create a transaction manually, but lumos has already provide a solution for simplifying transaction creation. Let's look at ",(0,i.kt)("inlineCode",{parentName:"p"},"TransactionSkeleton")," and how it works in lumos first."),(0,i.kt)("h3",{id:"transaction-skeleton"},"Transaction Skeleton"),(0,i.kt)("p",null,"CKB provides great flexibility for dapp developers to build anything they want. But we all know that ",(0,i.kt)("strong",{parentName:"p"},"with great power comes great responsibility"),", a flexible programming model also significantly complicates transaction assembling. This includes but might not be limited to the following hurdles:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Different scripts used in transaction inputs will require separate message generation, and also separate signing steps."),(0,i.kt)("li",{parentName:"ul"},"Some cells might require special argument setup in witness, due to type script validation rules."),(0,i.kt)("li",{parentName:"ul"},"Coordination might be required, since both lock script and type script in a cell might require arguments in the same witness construct.")),(0,i.kt)("p",null,"Those problems will haunt you even when you are dealing with a single NervosDAO transaction. It is only gonna get more complicated, when we consider multiple cells containing different CKB scripts composed together. Looking into the future, we will definitely need a solution to this issue."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TransactionSkeleton")," is the answer we propose in lumos. Each transaction skeleton corresponds to an action, and will be built into a single transaction that is ready to be submitted to CKB. Surrounding the idea of TransactionSkeleton, a series of conveniences are provided to aid transaction assembling:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A well designed component should automatically query and include cells to provide capacities required by the transaction."),(0,i.kt)("li",{parentName:"ul"},"Individual script logic should be managed and respected by the general transaction skeleton."),(0,i.kt)("li",{parentName:"ul"},"Scripts sharing the same behavior should be managed together in a unified interface. Developers can rely on abstractions instead of catering for every single detail.")),(0,i.kt)("p",null,"This still sounds quite complicated, let's walkthrough an example to see how we can leverage TransactionSkeleton."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> // In practice, you might already have the address at your hand, here we just\n> // want to demonstrate how this works.\n> const script = {\n  code_hash: "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",\n  hash_type: "type",\n  args: "0xcbfbb9edb5838e2d61061c3fc69eaaa5fdbd3273"\n};\n> const {generateAddress, parseAddress, createTransactionFromSkeleton,\n  sealTransaction, TransactionSkeleton } = require("@ckb-lumos/helpers");\n> const address = generateAddress(script);\n\n> // Now let\'s create the actual skeleton, and deposit CKBytes into the skeleton\n> let skeleton = TransactionSkeleton({ cellProvider: indexer });\n> const { secp256k1Blake160, dao } = require("@ckb-lumos/common-scripts");\n\n> // Using utility provided in common-scripts, let\'s deposit 1000 CKBytes into\n> // the skeleton. We will introduce common-scripts separately below. Here we are\n> // using the same address as from and to, but this does not have to be the case\n> // everywhere.\n> skeleton = await dao.deposit(skeleton, address, address, 100000000000n);\n\n> // createTransactionFromSkeleton is designed to build a final transaction, but\n> // there is nothing stopping you from using it to peek into the current skeleton.\n> console.log(JSON.stringify(createTransactionFromSkeleton(skeleton), null, 2));\n\n> // But this transaction is not yet complete, we still need 2 parts:\n> // * Transaction fee is not taken into consideration\n> // * The transaction is not signed yet\n> // Let\'s take a look at them separately.\n\n> // First, since we are using the default secp256k1-blake160 lock script, an\n> // existing module in common-scripts can be leveraged to incur transaction\n> // fee. Here we are using the same address to provide 1 CKByte as transaction\n> // fee.\n> skeleton = await secp256k1Blake160.payFee(skeleton, address, 100000000n);\n\n> // If you checked the transaction skeleton after incurring fees. You will\n> // notice that it only has one input. This might raise a question: if NervoDAO\n> // deposit consumes one input cell, transaction fee requires a different input\n> // cell, shouldn\'t there be 2 input cells with 3 output cells(a deposited cell,\n> // and 2 change cell)? The trick here, is that common-scripts is smart enough\n> // to figure out that the 2 actions here use the same address. Hence it just\n> // rewrite the change cell generated in the NervosDAO deposit action to pay\n> // enough transaction fee.\n> createTransactionFromSkeleton(skeleton).inputs.length;\n1\n\n> // Now the transaction is more or less complete, we can start generate messages\n> // used for signing.\n> skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n> // This method actually loops through the skeleton, and create `signingEntries`\n> // that are using the default secp256k1-blake160 lock script:\n> skeleton.get("signingEntries").toArray();\n[\n  {\n    type: \'witness_args_lock\',\n    index: 0,\n    message: \'0x40811fd6ed74b9042f603dc7f2f577da7ebe0e05175d349dbb5c539b1111b83f\'\n  }\n]\n')),(0,i.kt)("p",null,"Lumos, for now, does not handle message signing for the following reasons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is a serious matter that relates to the overall security of the dapp, we want to make sure we are doing this properly if/when we decide to do it."),(0,i.kt)("li",{parentName:"ul"},"Different dapps might have different requirements, some don't do signing at all, having signing built-in might render certain dapps hard to build.")),(0,i.kt)("p",null,"Using a secp256k1 tool, it's not hard to generate a signature here based on the private key listed above, and the message. And we can continue with this process:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> const signatures = ["0x1cb952fd224d1d14d07af621587e91a65ccb051d55ed1371b3b66d4fe169cf7758173882e4c02587cb54054d2de287cbb1fdc2fc21d848d7b320ee8c5826479901"];\n> const tx = sealTransaction(skeleton, signatures);\n')),(0,i.kt)("p",null,"Now we have a complete transaction assembled, and we can send it to CKB:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> const { RPC } = require("ckb-js-toolkit");\n> const rpc = new RPC("http://127.0.0.1:8114");\n> await rpc.send_transaction(tx);\n\'0x88536e8c25f5f8c89866dec6a5a1a6a72cccbe282963e4a7bfb5542b4c15d376\'\n')),(0,i.kt)("p",null,"Now we have successfully deposited CKBytes into CKB using lumos!"),(0,i.kt)("h2",{id:"withdraw"},"Withdraw"),(0,i.kt)("p",null,"The following code can help us list all deposited Nervos DAO cells for an address:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> for await (const cell of dao.listDaoCells(indexer, address, \"deposit\")) { console.log(cell); }\n{\n  cell_output: {\n    capacity: '0x174876e800',\n    lock: {\n      code_hash: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',\n      hash_type: 'type',\n      args: '0xcbfbb9edb5838e2d61061c3fc69eaaa5fdbd3273'\n    },\n    type: {\n      code_hash: '0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e',\n      hash_type: 'type',\n      args: '0x'\n    }\n  },\n  out_point: {\n    tx_hash: '0x88536e8c25f5f8c89866dec6a5a1a6a72cccbe282963e4a7bfb5542b4c15d376',\n    index: '0x0'\n  },\n  block_hash: '0xa1ec7dc291774bc0fc229efba4a162c099a8d88ffa7ae2fa410cc574e0701ced',\n  block_number: '0x196',\n  data: '0x0000000000000000'\n}\n")),(0,i.kt)("p",null,"Here we can find the cell we just deposited to Nervos DAO. Let's now try to withdraw it from Nervos DAO:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> // First, we will need to locate the cell. In a real dapp this is most likely\n> // coming from user selection.\n> const cell = (await dao.listDaoCells(indexer, address, \"deposit\").next()).value;\n> // For a new action, let's create a new transaction skeleton\n> skeleton = TransactionSkeleton({ cellProvider: indexer });\n> // This time, we invoke withdraw method to prepare a withdraw skeleton\n> skeleton = await dao.withdraw(skeleton, cell, address);\n> // Fees are also necessary\n> skeleton = await secp256k1Blake160.payFee(skeleton, address, 100000000n);\n> // And let's generate signing entries again.\n> skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n> skeleton.get(\"signingEntries\").toArray();\n[\n  {\n    type: 'witness_args_lock',\n    index: 0,\n    message: '0x24370c5cedc03c34ae0a00a10d9e62324bce07e8d155c839ff10991d73684c34'\n  }\n]\n> // After we signed the message, we can get the signature:\n> const signatures2 = [\"0x5aed4480c82844506fefc1d92dd18422a123b8e880018ea4cfa7f95891c4781e6578facedd765676831cf3cca04492ec3ec3885ac8d0b6d90cb6c1d6f99e6ffb01\"];\n> // Now we can seal and send the transaction\n> const tx2 = sealTransaction(skeleton, signatures2);\n> await rpc.send_transaction(tx2);\n'0xe411eb6a3cf4f659461cc7a9df9ff95a72b9624bf850b9ccad0c4d7f2ab444f6'\n")),(0,i.kt)("p",null,"See that withdrawing transaction is not so hard!"),(0,i.kt)("h3",{id:"locktime-pool"},"Locktime Pool"),(0,i.kt)("p",null,"We could've just showed the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nervosnetwork/lumos/blob/ac96a3220ab2a148425120eaac216abe246ee1da/packages/common-scripts/index.d.ts#L262"},"unlock")," method in ",(0,i.kt)("inlineCode",{parentName:"p"},"dao")," module, which let you complete the withdrawing from Nervos DAO. But here I want to talk about a different construct in lumos: locktime pool."),(0,i.kt)("p",null,"If you look closer, you would notice that the cell consumed in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.md#withdraw-phase-2"},"withdraw phase 2"),", is really nothing but a cell with a certain lock period. Likewise, there might be other scripts on CKB, when combined with certain cell, just provide lock periods. The multisig script included in genesis cell, is one such example. So the idea arises: what if we build a unified pool, that handles all cells that have lock periods? When designed properly, we can ignore the fact that they might come from different dapps, using different scripts. What we do care, is that each of those cells comes with a capacity and lock period, when the lock period is reached, they are nothing but ordinary cells in one's wallet."),(0,i.kt)("p",null,"Given this thought, we designed ",(0,i.kt)("inlineCode",{parentName:"p"},"locktime pool")," in lumos. Right now it only processes Nervos DAO cells in withdraw phase 2 and multisig cells, but in the future there is nothing stopping us from integrating more scripts that provide lock periods. From a developer point of view, locktime pool, can be used to manage all of them, provide a unified view in dapps."),(0,i.kt)("p",null,"As usual, we can query for all cells currently in the locktime pool:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> const { locktimePool } = require(\"@ckb-lumos/common-scripts\");\n> for await (const cell of locktimePool.collectCells(indexer, address)) { console.log(cell); }\n{\n  cell_output: {\n    capacity: '0x174876e800',\n    lock: {\n      code_hash: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',\n      hash_type: 'type',\n      args: '0xcbfbb9edb5838e2d61061c3fc69eaaa5fdbd3273'\n    },\n    type: {\n      code_hash: '0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e',\n      hash_type: 'type',\n      args: '0x'\n    }\n  },\n  out_point: {\n    tx_hash: '0xe411eb6a3cf4f659461cc7a9df9ff95a72b9624bf850b9ccad0c4d7f2ab444f6',\n    index: '0x0'\n  },\n  block_hash: '0xb468ec0a1aed1f7070fc00952453ac882dbe36b1afbfb520c822fe46b3b81dfe',\n  block_number: '0x543',\n  data: '0x9601000000000000',\n  maximumCapacity: 100153459536n,\n  since: '0x20000a00060000dc',\n  depositBlockHash: '0xa1ec7dc291774bc0fc229efba4a162c099a8d88ffa7ae2fa410cc574e0701ced',\n  withdrawBlockHash: '0xb468ec0a1aed1f7070fc00952453ac882dbe36b1afbfb520c822fe46b3b81dfe',\n  sinceBaseValue: undefined\n}\n")),(0,i.kt)("p",null,"Here we can found the cell just created from NervosDAO withdrawing step. Let's try to consume it using locktimePool:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> // Notice you will wait till the lock period of the cell has passed, otherwise this function would throw an error:\n> skeleton = await locktimePool.transfer(skeleton, [address], address, 100153459536n, (await rpc.get_tip_header()));\n> console.log(JSON.stringify(createTransactionFromSkeleton(skeleton), null, 2));\n{\n  "version": "0x0",\n  "cell_deps": [],\n  "header_deps": [],\n  "inputs": [],\n  "outputs": [],\n  "outputs_data": [],\n  "witnesses": []\n}\n')),(0,i.kt)("p",null,"This might actually be a surprise: we invoked transfer method, but it does nothing! Turns out the reason here, is that we are using the same address as both transfer input, and transfer output. Lumos is smart enough to figure out that when you are using the same input and output, we don't need to perform the action so as to save certain transaction fee."),(0,i.kt)("p",null,"One different question you might ask, is that we use the same address in deposit and withdraw steps, why those previous attempts work? The reason for this, is that deposited cell, or created cell in withdraw step 1 has special purposes, they represent unique ",(0,i.kt)("strong",{parentName:"p"},"actions")," that we want to perform, hence they are ",(0,i.kt)("strong",{parentName:"p"},"freezed")," in the transaction skeleton, so later when we optimize the transaction to combine inputs/outputs, we won't touch those specially created cells. On the other hand, in locktime pool design, we treat a cell with expired lock period the same as a normal cell, they really have nothing different, hence here, lumos will try to optimize the transaction, by removing the action transferring amount from an address to itself. In lumos' eye, this is a no-op."),(0,i.kt)("p",null,"Now let's try the same step using a different target address:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> skeleton = await locktimePool.transfer(skeleton, [address], \"ckt1qyqx57xrsztnq7g5mlw6r998uyc2f5hm3vnsvgsaet\", 100153459536n, (await rpc.get_tip_header()));\n> skeleton = await secp256k1Blake160.payFee(skeleton, address, 100000000n);\n> skeleton = secp256k1Blake160.prepareSigningEntries(skeleton);\n> skeleton.get(\"signingEntries\").toArray();\n[\n  {\n    type: 'witness_args_lock',\n    index: 0,\n    message: '0xf01fb9988ba0265597760f50df92a56162d650b119cc95e8508079af584bdbc7'\n  }\n]\n")),(0,i.kt)("p",null,"We can generate the signature as always:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> const signatures3 = [\"0x6edde41592b41d445fabfd1b1d6854cf643bba724a338b5751827d991affa5a979d12339250bf5ade45f7f2742cba1e3de0791e37ef03914459bcdd099908ec601\"];\n> const tx3 = sealTransaction(skeleton, signatures3);\n> await rpc.send_transaction(tx3);\n'0xbaa7bdd71b7ec975f5a75c49d300857981f333c4346d6d6de1297d8d9d9ce0e0'\n")),(0,i.kt)("p",null,"This is really the core part of this post, if you are not understanding this part, we recommend you to read it again, and try it in CKB by yourself. What we are showing here, is that by designing a set of common APIs, we can build a general facility, that manages many different script instances, given the fact that they share the same behavior. And it is really not only the secp256k1-blake160 single signing script that shall be managed by a wallet. Any scripts that follow certain behavior, can be treated as a cell managed in a wallet."),(0,i.kt)("h2",{id:"common-script"},"Common Script"),(0,i.kt)("p",null,"As we show above, locktime pool is one step ahead of the journey at managing different cells/scripts with similar behaviors. But we are not stopping here, we can continue further down the path: it is mentioned above, that those cells with lock period already passed, can be thought as normal cells. Can we treat them as usual, without needing to deal with locktime pool?"),(0,i.kt)("p",null,"We have build ",(0,i.kt)("inlineCode",{parentName:"p"},"common")," module for this. Given a set of address/configurations(since for some P2SH script, address alone won't be enough), it can manage all cells using those scripts, including cells with expired lock period. Right now this includes the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"secp256k1-blake160 single signing script"),(0,i.kt)("li",{parentName:"ul"},"secp256k1-blake160 multiple signing script"),(0,i.kt)("li",{parentName:"ul"},"NervosDAO script(only cells in withdraw phase 2 are managed)")),(0,i.kt)("p",null,"And the list doesn't stop here, we are working to provide a common API specification, that once implemented, can enable ",(0,i.kt)("inlineCode",{parentName:"p"},"common")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"locktime pool")," to support those additional scripts as well. We do hope those 2 modules can help enable a unified cell manager in lumos, in which ",(0,i.kt)("inlineCode",{parentName:"p"},"common")," handles all consumable cells, while ",(0,i.kt)("inlineCode",{parentName:"p"},"locktime pool")," gives insights into cells that are locked now but will be usable in the future."),(0,i.kt)("h2",{id:"recap"},"Recap"),(0,i.kt)("p",null,"Lumos aims to take care of the full lifecycle of your CKB dapp. In this post, we are just taking a sneak peek at all the powers. We will continue to work on documents as well as sample projects to showcase all the powers enabled by lumos. We welcome all of you to try out lumos, and tell us what you think of it. So we can continue enhancing it, to make it the beloved framework for building CKB dapps."))}u.isMDXComponent=!0}}]);